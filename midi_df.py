#Dependencies

import json
import pandas as pd
import numpy as np
import midi
import copy

#Internal methods

def pitch(n):
    '''Return the pitch of a note event. Used in midi_to_df(). If "n" is not a note event, return None.
    
    Return type: int or None
    '''
    if type(n)==midi.events.NoteOnEvent or type(n)==midi.events.NoteOffEvent:
        return n.pitch
    else:
        return None

def on_off(n):
    '''Return the state of certain midi events. Used in midi_to_df(). States include on, off, pdup (pedal up), eot (end of track), and None.
    
    Return type: str
    '''
    if type(n)==midi.events.NoteOffEvent:
        return "off"
    elif type(n)==midi.events.EndOfTrackEvent:
        return "eot"
    elif type(n)==midi.events.NoteOnEvent:
        if n.velocity > 0:
            return "on"
        else:
            return "off"
    elif pedal_state(n) == "up":
        return "pdup"
    else:
        return "None"
    
def pedal_state(n):
    '''Return the pedal position of a sustain pedal midi event. Used in on_off(). States include up, down, and None
    
    Return type: str
    '''
    if type(n)==midi.events.ControlChangeEvent:
        if n.data[0]==64:
            if n.data[1] <64:
                return "up"
            else:
                return "down"
    else:
        return "None"

def linear(x0,x1,y1,x2,y2):
    '''Calculate the y-position at x0 on a line passing through (x1,y1) and (x2,y2). Used in get_time().
    
    Return type: float64
    '''
    m = (y2-y1)/(x2-x1)
    y0 = m*(x0-x1)+y1
    return y0

def get_time(ticks, tmap, u=False, min_row=0): 
    '''Calculate the time at which a midi tick is reached based on a tempo map. Used in midi_to_df(). Returns a tuple containing the calculated time, and the last index of the tempo map used in the calculation.
    
    Return type: tuple (float64, int)
    Parameters:
    ticks: int or float64
        The midi tick number (absolute) at which the midi event plays. A tick is defined as some fraction of a quarter note.
    tmap: pandas.DataFrame as generated by the tempo_df() function
        The tempo map with which the time is calculated.
    u: boolean, default False
        If True, return time in microseconds. Otherwise return time in seconds.
    min_row: int, default 0
        Determines which row to start looking through the tempo map, to prevent redundancy when iterating over large and dense tempo maps.
    '''
    for i in range(min_row,len(tmap)):
        if tmap["Tick"][i] <= ticks:
            ind = i
        else:
            break
    if ind < len(tmap)-1:
        time = linear(ticks,tmap["Tick"][ind],tmap["Time (sec)"][ind],
                            tmap["Tick"][ind+1],tmap["Time (sec)"][ind+1])
    else:
        spt = tmap["uSec/tick"][ind]/10**6
        lastick = tmap["Tick"][ind]
        time=tmap["Time (sec)"][ind]+(ticks-lastick)*spt
    
    if u:
        return (time*10**6,ind)
    else:
        return (time,ind)

def fill_list(series,fv=0):
    '''Fill every cell containing a specified value in a list or series with the value before it. Used in merge_tracks().
    
    Return type: list
    Parameters:
    series: pandas.Series, list, or other array-like
        The data series to fill.
    fv: object, default 0
        The data value to replace.
    '''
    p1 = list(series)

    for i in range(len(series)):
        if p1[i]==fv:
            if i==0:
                p1[i]=[]
            else:
                p1[i]=p1[i-1]
    return p1

def list_combine(lists, drop_dups=True):
    '''Combine several lists into one. Used in list_combine_series(). Effectively a generalization of the list.extend() method.
    
    Return type: list
    Parameters:
    lists: list of lists
        The set of lists to be combined. 
    drop_dups: bool, default True
        If True, eliminate duplicate elements.
    '''
    x=[]
    for l in lists:
        x.extend(l)
    if drop_dups:
        return list(set(x))
    return x

def list_combine_series(df, drop_dups=True):
    '''Combine multiple Series of lists into a series of combined lists. Used in merge_tracks(). A substitute for calling pandas.DataFrame.apply(list_combine,axis=1), to allow the use of lists.
    
    Return type: list of lists
    Parameters:
    df: pandas.DataFrame, whose elements are lists
        The DataFrame to process. All columns should be Series of lists. 
    drop_dups: bool, default True
        If True, eliminate duplicate elements in each new list.
    '''
    s_list = []
    for col in df:
        s_list.append(list(df[col]))
    x = []
    for i in range(len(s_list[0])):
        x.append(list_combine([s_list[j][i] for j in range(len(s_list))], drop_dups=drop_dups))
    return x

#Summary and utilities

def track_summary(midifile,recommend=False,melodic=False):
    '''Output an overview of the tracks in a midi file, including name, channel, instrument ids, and which track contains the tempo map.
    
    Return type: pandas.DataFrame
    Parameters: 
    midifile: midi.Pattern
        The midi file to analyze, as loaded by midi.read_midifile().
    recommend: bool, default False
        If True, print a list of tracks with melodic note information (i.e., contains note events with a channel other than 9).
    melodic: bool, default False
        If True, only include tracks with note events on channels other than 9.
    ''' 
    titles=[]
    channels=[]
    note_counts=[]
    tempos=[]
    instruments=[]
    for track in midifile:
        try:
            titles.append([e.text for e in track if type(e)== midi.events.TrackNameEvent][0])
        except IndexError:
            titles.append("")

        try:
            channels.append(list({e.channel for e in track if type(e) == midi.events.NoteOnEvent})[0])
        except IndexError:
            channels.append("")

        note_counts.append(len([e.channel for e in track if type(e) in (midi.events.NoteOnEvent,midi.events.NoteOffEvent)]))

        if len([e for e in track if type(e)== midi.events.SetTempoEvent])>0:
            tempos.append("tempo track")
        else:
            tempos.append(" ")

        instruments.append({e.data[0] for e in track if type(e)== midi.events.ProgramChangeEvent})
    
    tracks_df = pd.DataFrame({"Track Name":titles, "Channel":channels, "Note Events": note_counts, 
                  "Tempo Track":tempos,"Instrument ID":instruments})
    tracks_df = tracks_df[["Track Name","Channel", "Note Events", "Tempo Track", "Instrument ID"]]
    
    note_tracks=tracks_df.loc[tracks_df["Channel"]!=9].loc[tracks_df["Note Events"]>0]
    if recommend:
        print("Recommended Tracks:",list(note_tracks.index))
    if melodic:
        return note_tracks
    return tracks_df

def max_notes(df):
    '''Return the maximum array size (i.e. biggest chord) in a DataFrame's "Playing" column. Accepts a pandas.DataFrame as generated by midi_to_df(), condense_df(), or merge_tracks().
    
    Return type: int
    '''
    return max([len(x) for x in df["Playing"]])

def max_dyads(df):
    '''Return the number of dyads (note pairs) in the biggest chord in a DataFrame's "Playing" column. Accepts a pandas.DataFrame as generated by midi_to_df(), condense_df(), or merge_tracks().
    
    Return type: int
    '''
    x = max_notes(df)
    return x*(x-1)/2

def format_json(file, indent=2):
    '''Return (as a string) a pretty-printed version of a json file generated by output_json(). Distinct from normal pprint in that it keeps the each note list on one line.
    
    Return type: str
    Parameters:
    file: str
        The path of the json file to format. Only useful with json files generated by output_json().
    indent: int
        Indent level of the pretty-printed json file.
    '''
    with open(file, "r") as song_j:
        song_fmt1 = json.dumps(json.loads(song_j.readline()), indent=indent, sort_keys=False)
    song_fmt = song_fmt1.replace("\n"+3*indent*" ","").replace("\n"+2*indent*" "+"]", "]")
    return song_fmt

def dyad_counts(chord):
    '''Calculate the number of instances of each interval class (unison to tritone) between the notes in a chord list.
    
    Return type: pandas.Series
    Parameters:
    chord: list of ints
        The chord object (list of pitches) to calculate counts on.
    '''
    chord_ints=[x-y for x in chord for y in chord if x>y]
    dyad_counts = pd.Series([6-abs(6-x%12) for x in chord_ints]).value_counts(sort=False)
    return dyad_counts

def dyad_counts_df(df, btp=True):
    '''Calculate the number of instances of each interval class (unison to tritone) playing at each timepoint for a condensed midi DataFrame.
    
    Return type: pandas.DataFrame
    Parameters:
    df: pandas.DataFrame as generated by condense_df() or merge_tracks()
        The condensed midi DataFrame to process.
    btp: bool, default True
        If true, include the "Beat", "Time(s)", and "Playing" columns of the input DataFrame.
    '''
    dc_list = []
    
    for row in df.iterrows():
        chord = row[1]["Playing"]
        dc_dict=dict(dyad_counts(chord))
        
        for i in range(7):
            if i not in dc_dict.keys():
                dc_dict[i]=0
                
        dc_dict["sum"] = sum(dc_dict.values())
        dc_list.append(dc_dict)
        
    dc_df = pd.DataFrame(dc_list)[[0,1,2,3,4,5,6,"sum"]]
    
    if btp:
        df_m=df[["Beat","Time (s)","Playing"]].reset_index(drop=True).merge(dc_df, left_index=True,right_index=True,)
        return df_m
    else:
        return dc_df

def max_dyad_counts(df):
    '''Calculate the maximum simultaneous instances of each interval class (unison to tritone) for a midi DataFrame.
    
    Return type: pandas.Series
    '''
    return dyad_counts_df(df,btp=False).max()


#Main DataFrame methods

def tempo_df(midifile,ch=0):
    '''Generate a tempo map DataFrame from a midi file, for use with the midi_to_df() method. 
    Output columns "Tick" (the midi tick on which each SetTempoEvent happens), "uSec/tick" (how long a tick lasts in microseconds as determined by the SetTempoEvent), "Time(sec)" (absolute time in seconds), and "Time(uSec)" (absolute time in microseconds).
    
    Return type: pandas.DataFrame
    Parameters:
    midifile: midi.Pattern
        The midi file to analyze, as loaded by midi.read_midifile().
    ch: int, default 0
        The track to read for tempo events, best determined by track_summary().
    '''
    if midifile.tick_relative:
        midi_abs = copy.deepcopy(midifile)
        midi_abs.make_ticks_abs()
    else:
        midi_abs = midifile
        
    tempo_map = [{"Tick": t.tick, "uSec/tick": t.get_mpqn()/midi_abs.resolution} for t in midi_abs[ch] if type(t)==midi.events.SetTempoEvent]
    tempo_map_df=pd.DataFrame(tempo_map)
    timestamps=[]
    for i in range(len(tempo_map)):
        if i==0:
            ts = 0
        else:
            ts=timestamps[i-1]+(tempo_map[i]["Tick"]-tempo_map[i-1]["Tick"])*tempo_map[i-1]["uSec/tick"]
        timestamps.append(ts)
    
    tempo_map_df["Time (uSec)"]=timestamps
    tempo_map_df["Time (uSec)"]=tempo_map_df["Time (uSec)"].map(round)
    tempo_map_df["Time (sec)"]=tempo_map_df["Time (uSec)"]/10**6
    return tempo_map_df

def midi_to_df(midifile, track, tempo_map_df=None,pedal=False):
    '''Return a DataFrame containing information on each midi event in a specified midi.Track, including time, pitch, beat, and current chord.
    
    Return type: pandas.DataFrame
    Parameters:
    midifile: midi.Pattern
        The midi file to analyze, as loaded by midi.read_midifile().
    track: int
        Which midi.Track to analyze. Consult track_summary() for a list of note tracks in the file.
    tempo_map_df: pandas.DataFrame as generated by tempo_df(), default None
        The tempo map with which to calculate the Time(sec) of midi events. If None, creates a tempo map using track 0 of the midi Pattern.
    pedal: bool, default False
        Whether to account for sustain pedal events when determining chords. If True, all notes played after a pedal down event are considered to be sounding until the next pedal up event.
    '''
    diff_ticks = [n.tick for n in midifile[track]]
    pitches = [pitch(n) for n in midifile[track]]
    onoff = [on_off(n) for n in midifile[track]]
    sum_ticks = [sum(diff_ticks[:i+1]) for i in range(len(midifile[track]))]
    notes_playing = []
    notes_list = []

    if pedal:
        peds = [pedal_state(n) for n in midifile[track]]
        sus=[]
        p_dn = False
        for i in range(len(midifile[track])):
            #Toggle pedal state based on midi event
            if peds[i] == "down":
                p_dn=True
            elif peds[i] == "up":
                p_dn=False
                #Remove "stale" notes from notes_playing
                for note in sus:
                    notes_playing.remove(note)
                sus=[]
            else:
                #For NoteEvents
                if p_dn:
                    #If pedal is down, check if note is already playing,
                    #then add it to notes_playing and remove it from sus
                    if onoff[i]=="on":
                        if pitches[i] not in notes_playing:
                            notes_playing.append(pitches[i])
                        if pitches[i] in sus:
                            sus.remove(pitches[i])
                    elif onoff[i]=="off":
                        #If pedal is down, add ended note to sus
                        if pitches[i] not in sus:
                            sus.append(pitches[i])
                else:
                    if onoff[i]=="on":
                        notes_playing.append(pitches[i])
                    elif onoff[i]=="off":
                        notes_playing.remove(pitches[i])
            notes_list.append(notes_playing[:])
        
    else:
        for i in range(len(midifile[track])):
            if onoff[i]=="on":
                notes_playing.append(pitches[i])
            elif onoff[i]=="off":
                if pitches[i] in notes_playing:
                    notes_playing.remove(pitches[i])
            notes_list.append(notes_playing[:])

    track_df = pd.DataFrame({"dTicks":diff_ticks,"Pitch":pitches, "On/Off":onoff,
                  "Tick":sum_ticks,"Playing":notes_list})[["dTicks","Tick","Pitch","On/Off","Playing"]]
    if tempo_map_df is None:
        tempo_map_df = tempo_df(midifile)
        
    #track_df["Time (s)"]=track_df["Tick"].map(lambda x: get_time(x,tempo_map_df))

    time_s = []
    last_ind = 0
    for j in range(len(track_df)):
        gt = get_time(track_df["Tick"][j],tempo_map_df,min_row=last_ind)
        time_s.append(gt[0])
        last_ind = max(gt[1]-1,0)
        #print(gt[1])
    track_df["Time (s)"]=time_s

    track_df["Beat"]=track_df["Tick"]/midifile.resolution

    return track_df

def condense_df(midi_df):
    '''Condense a midi DataFrame (midi_to_df()) to contain only note on/off events at distinct timepoints, ready for output as json data. All chord information is preserved.
    
    Return type: pandas.DataFrame
    Parameters:
    midi_df: pandas.DataFrame as generated by midi_to_df()
        The midi DataFrame to condense.
    '''
    df1=midi_df.loc[midi_df["On/Off"]!="None"]
    df2=df1.loc[df1["Tick"].shift(-1)-df1["Tick"]!=0]
    return df2[["Beat","Time (s)","Playing"]]

def merge_tracks(df_list, ch_list=None,drop=False,reset_index=False):
    '''Merge multiple condensed midi DataFrames into one table. "Playing" column contains the combination of all chords playing at a given timepoint.
    
    Return type: pandas.DataFrame
    Parameters:
    df_list: list of pandas.DataFrame objects as generated by condense_df()
        The condensed midi DataFrames to combine. 
    ch_list: list of ints, default None
        The list of track id's for accurate labeling of columns. If none, label "Playing #" columns incrementally starting with 1.
    drop: bool, default False
        If True, drop all "Playing #" columns to leave only the combined "Playing" column.
    reset_index: bool, default False
        If True, reset the index column of the DataFrame. Otherwise may retain asynchronous index numbers from the various input DataFrames.
    '''
    if ch_list is None:
        ch_list=[i+1 for i in range(len(df_list))]
    
    df_named_list = []
    j=0
    for df in df_list:
        df_named_list.append(df.rename(columns={"Playing":f"Playing {ch_list[j]}"}))
        j+=1
    
    merged = df_named_list[0]
    for df in df_named_list[1:]:
        merged = merged.merge(df, on=["Beat","Time (s)"],how="outer").sort_values("Beat").fillna(0)
    
    for col in merged.iloc[:,2:]:
        merged[col]=fill_list(merged[col])
    
    merged["Playing"]=list_combine_series(merged.iloc[:,2:])
    if drop:
        merged = merged[["Beat","Time (s)","Playing"]]
    if reset_index:
        merged = merged.reset_index(drop=True)
    return merged

def output_json(df, filename,all_tracks=False):
    '''Save a condensed midi DataFrame as a json file.
    
    Return type: NoneType
    Parameters:
    df: pandas.DataFrame as generated by condense_df() or merge_df()
        The condensed midi DataFrame to output.
    filename: str
        The name of the output file. Will append ".json" if necessary.
    all_tracks: bool, default False
        If True, include all "Playing #" columns of a merged midi DataFrame in the output file. 
    '''
    filename=filename.split(".json")[0]
    if all_tracks:
        df.to_json(f"{filename}.json",orient="records")
    else:
        df[["Beat","Time (s)","Playing"]].to_json(f"{filename}.json",orient="records")

